# HTTP Request smugling

1. Нормализация HTTP заголовков;
2. Не выстраивать несколько видов серверов под одну цепочку запросов;
3. Ограничение keeplife (повторного использования соединений с бэкендом) не является прямым способом защиты от HTTP Request Smuggling. Уязвимость возникает из-за различий в обработке запросов между фронтендом и бэкендом, и повторное использование соединений может способствовать «перетеканию» данных между запросами, что является основой для атак;
4. Корректная настройка Proxy.

## В Apache

- **Запретить повторное использование соединений с бэкендом**. Это исключит возможность «перетекания» данных между запросами.
- **Унифицировать ПО** на фронтенде и бэкенде — использование одинакового программного обеспечения минимизирует различия в обработке запросов.
- **Внедрить WAF (Web Application Firewall) с функцией обнаружения аномалий** — современные WAF способны анализировать трафик и блокировать подозрительные запросы, включая попытки HTTP Request Smuggling.
## В Nginx

- **Настроить модуль ngx_http_upstream_keepalive_module** — он создаёт пул «праздных» соединений на воркер и возвращает их в работу при новых запросах. **Важно**:
    - **keepalive** — максимальное число неиспользуемых (idle) соединений на воркер к каждому upstream-серверу.
    - **keepalive_requests** — сколько запросов можно обработать по одному соединению, после чего оно закрывается и создаётся заново (ротация).
    - **keepalive_timeout** — сколько держать соединение в idle до закрытия.
- **Отрегулировать размеры пула и таймауты** по факту, учитывая пиковую нагрузку и автомасштабирование.
- **Разделять локации по профилю** — для длинных запросов (загрузки, стримы) держать отдельные location с другими таймаутами, чтобы не «забивать» пул.
## В HAProxy

- **Использовать HTX-режим** — он нормализует HTTP-представление и защищает от ряда неочевидных кейсов, включая HTTP Request Smuggling. В новых ветках HTX включён по умолчанию, но лучше задать его явно.
- **Настроить опцию http-buffer-request** — она заставляет фронт прочитать запрос целиком до отправки к бэкенду, снижая риск десинхронизации.
- **Удалять hop-by-hop-заголовки** и явно запрещать дубликаты Content-Length.

**Важно**: для защиты от HTTP Request Smuggling рекомендуется использовать современные версии протокола — HTTP/2 и HTTP/3 — у которых есть встроенные механизмы для предотвращения подобных атак.

---

# Open Redirect

1. Белые списки;
2. Предупреждения о покидании ресурса, переход по клику.

---

# Race Condition

1. Архитектурное исключение разделяемого, изменяемого состояния: Шардирование по пользователям (User-Based Sharding); Event Sourcing;
2. Pessimistic Locking;
3. Сериализация операций;
4. Optimistic Locking;
5. Атомарные операции;
6. Сериализация через очередь (не лучший подход)

---

# SSRF

1. Поместить модуль загрузки внешних источников в Docker контейнер, который не сможет входить во внутреннюю сеть;
2. WAF, Proxy;
3. Кэширование DNS с проверкой на обращение во внутреннюю сеть (от DNS Rebinding) 