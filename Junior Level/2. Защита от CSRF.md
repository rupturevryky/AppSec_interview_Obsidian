Ключевая угроза CSRF — это несанкционированное выполнение действий от лица пользователя без его ведома, если жертва уже аутентифицирована в системе (например, перевод денег, смена email).

# **Основные, реально работающие меры защиты:**

## 1. **CSRF-токены**  

   Самая универсальная практика: при каждом важном POST/PUT/DELETE-запросе сервер генерирует уникальный, непредсказуемый токен, который встраивается в HTML-форму или заголовок. Токен хранится только на стороне пользователя и отправляется в теле формы/запроса; злоумышленник, действующий с другого сайта, этот токен знать не может.

---

Основные виды CSRF-токенов, которые применяются на практике:

1. **Synchronizer Token (Single/Per-request token, Bearer token)**  
   — Самый классический CSRF-токен.  
   — Уникальное, случайное значение, связанное с сессией пользователя.  
   — Выдается сервером, обычно встраивается в каждую HTML-форму hidden-полем, и отправляется на сервер вместе с POST/PUT/DELETE-запросом.  
   — Может меняться после каждого запроса (per-request) или жить в рамках одной сессии (per-session).

2. **Double Submit Cookie Token**  
   — CSRF-токен записывается одновременно в cookie (обычно не httpOnly) и в форму/заголовок.  
   — При отправке изменяющего запроса токен приходит дважды: как cookie и как значение поля (или custom header).  
   — Сервер сравнивает их, и если не совпадают — отклоняет запрос.  
   — Подход удобен для SPA и API.

3. **Encrypted/Stateless Token (например, JWT как CSRF-токен)**  
   — Вместо хранения токена на сервере, его содержимое (time, userID, session) шифруется — часто через JWT.  
   — Токен передается клиенту и валидируется сервером по подписи.  
   — Используется для статeless-приложений, микросервисов или распределённых API.

4. **Custom header token**  
   — В современных SPA (Angular, React, Vue) CSRF-токен часто передается в custom HTTP header (`X-CSRF-Token`).  
   — Браузерный SOP не позволяет стороннему сайту выставить custom header, так что атака невозможна без доступа к JS внутри исходного origin.

5. **One-time/Expiring CSRF Token**  
   — Реализация с коротким TTL (вплоть до одноразового токена на каждый запрос или действие), чтобы даже в случае компрометации злоумышленник не успел его использовать.

---

**Резюме:**  
Классика — synchronizer (per-request/per-session), в SPA — double submit или custom header/JWT. Выбор схемы зависит от архитектуры: главное, чтобы токен был уникальным, непредсказуемым, валидировался на сервере и не был доступен злоумышленнику с другого origin.

---

## 3. **SameSite cookies**  

   Установка cookie-флага `SameSite=Strict` либо хотя бы `Lax`. Это минимизирует риски, потому что при переходах с других сайтов браузер не будет отправлять cookie (особенно аутентификационные) в сторонние контексты.

## 4. **Проверка заголовков Origin/Referer**  

Для “чувствительных” действий стоит верифицировать, что запрос пришёл с “правильной” страницы (Origin совпадает с нашим доменом). Это не идеальная, но дополнительно рабочая мера — особенно если токены применять не всегда возможно.

## 5. **Ограничение чувстительных операций только на POST**  

GET-запросы не должны изменять состояние (ни перевод, ни logout, ни настройка профиля) — только через POST/PUT/DELETE и только с токеном.

## 6. **CORS**  

Не выдавать неавторизованные методы или эндпоинты в рамках CORS (т.е. оставить CORS-политику по умолчанию для защищённых API). Это дополнительный слой, который защитит API от некоторых вариантов CSRF.