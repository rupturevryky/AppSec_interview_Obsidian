
---

# **Часть 1: Фундамент. Транспортный уровень (TCP & UDP) в контексте безопасности**

Зафиксируемся на **4-м (Транспортном) уровне**.

**Ключевая задача транспортного уровня:** обеспечить обмен данными между приложениями на разных хостах, используя **порты** в качестве идентификаторов сервисов.

## **1. UDP (User Datagram Protocol)**

- **Суть:** Простой, **неустановочный** протокол. Нет предварительного соединения ("рукопожатия").
- **Пакет (датаграмма):** Каждый пакет независим. Заголовок мал (8 байт: порты отправителя/получателя, длина, контрольная сумма).
- **Гарантии:** **Нет гарантий доставки, порядка следования, контроля перегрузки.** Пакеты могут теряться, дублироваться, приходить не по порядку.
- **Плюсы:** Минимальные задержки, низкие накладные расходы.
- **Применение:** Реальное время — голосовая связь (VoIP), видеостримы, онлайн-игры, DNS-запросы.
- **Взгляд хакера:** Из-за отсутствия проверок UDP — цель для **спуфинга** (подмены IP/порта), **флуда** (UDP flood — DDoS-атака). Контрольная сумма часто слабая защита.

## **2. TCP (Transmission Control Protocol)**

- **Суть:** Сложный, **установочный**, надежный протокол с управлением потоком.
- **Соединение:** Устанавливается через **трехстороннее рукопожатие (SYN, SYN-ACK, ACK)**. Закрывается через FIN-пакеты.
- **Гарантии:** Гарантированная **доставка** (подтверждения ACK), **порядок следования** (номера последовательности), **контроль перегрузки** и **целостность** данных.
- **Поток:** Данные передаются как **непрерывный поток байтов**, а не как отдельные сообщения. Для управления эффективностью используется **"скользящее окно"**.
- **Взгляд хакера:**
>    - **Атаки на установление соединения:** **SYN-flood** (отправка множества SYN без завершения рукопожатия — истощение ресурсов сервера).
>    - **Спуфинг сессии:** Перехват или предсказание **номера последовательности**, чтобы "встроиться" в чужое соединение (сложно в современных сетях).
>    - **Атаки на механизмы управления:** Злоупотребление алгоритмами контроля перегрузки (`cubic`, `reno`, `bbr`).
>    - **Сканирование портов:** Анализ ответов (SYN-ACK, RST) на TCP-пакеты для выявления открытых портов и ОС (`nmap -sS`).

>[!info] **Что такое "Контроль перегрузки" (Congestion Control) в TCP**
>Это **встроенный механизм** в протокол TCP, который позволяет **автоматически регулировать скорость отправки данных** в зависимости от загруженности сети.
>
>**Аналогия:** Представьте, что вы наливаете воду в воронку.
>- Если лить слишком быстро — вода перельется через край (**потеря пакетов**).
>- Если лить медленно — вы неэффективно используете время.
>- Идеально — лить с максимально возможной скоростью, но так, чтобы воронка успевала (использовать всю доступную пропускную способность канала, но не перегружать его).


**Как это работает в TCP:**  
У отправителя есть переменная **"Окно перегрузки" (Congestion Window, cwnd)**. Она определяет, сколько байтов можно отправить, не дожидаясь подтверждения (ACK).
- **Если сеть свободна (пакеты доходят, ACK приходят вовремя):** Окно **расширяется** (скорость растет).
- **Если сеть перегружена (пакеты теряются, ACK не приходят):** Окно **резко сокращается** (скорость падает).

Алгоритмы **`cubic` (по умолчанию в Linux), `reno`, `bbr` (от Google)** — это просто разные математические модели для того, **как именно** расширять и сокращать это окно.

---

### **Как можно злоупотребить этими алгоритмами (Атаки)?**

Цель злоумышленника — **нарушить нормальную работу механизма контроля перегрузки у жертвы**, чтобы либо **замедлить её соединение (атака на доступность)**, либо **получить нечестное преимущество в скорости (атака на справедливость)**.

#### **Способ 1: Подделка ACK-пакетов (Ack Suppression / Optimistic Acking)**

- **Суть:** Злоумышленник, находясь "на пути" (Man-in-the-Middle) или подделав IP, отправляет **ложные ACK-пакеты** от имени получателя.
- **Как это вредит:**
>- **Слишком ранние ACK (Optimistic Acks):** Отправитель получает ACK раньше, чем пакет реально дошел до получателя. Алгоритм (например, `reno`) думает, что сеть очень быстрая, и начинает **бесконтрольно увеличивать скорость**, что в итоге приводит к перегрузке и реальным потерям пакетов **у других, честных пользователей**.
>- **Подделка дубликатов ACK (DupACK spoofing):** Если отправитель теряет пакет, он ждет 3 дублирующих ACK, чтобы понять потерю и быстро переслать пакет (быстрая ретрансмиссия). Злоумышленник может послать эти ложные DupACK, заставив отправителя **без необходимости снижать скорость** (думая, что пакет потерян) и тратить ресурсы на повторную отправку.

#### **Способ 2: Искусственная провокация потерь пакетов**

- **Суть:** Злоумышленник целенаправленно **сбрасывает (drop) или искажает** некоторые пакеты TCP от жертвы.
- **Как это вредит:** Любой алгоритм контроля перегрузки (`cubic`, `reno`) интерпретирует потерю пакета как главный признак перегрузки в сети. В ответ он **резко, в разы, сокращает скорость отправки**. Если делать это периодически, можно держать скорость соединения жертвы на минимальном уровне, не давая ей использовать полную пропускную способность.

#### **Способ 3: Атака на "честность" протокола (Exploiting TCP Fairness)**

- **Контекст:** В идеальном мире все TCP-соединения в перегруженной сети делят полосу пропускания **поровну**. Эту "честность" обеспечивают алгоритмы.
- **Атака:** Злоумышленник настраивает свое TCP-соединение так, чтобы оно **игнорировало стандартные алгоритмы** и вело себя агрессивно (например, используя модифицированную версию стека TCP, которая не снижает окно при потерях).
- **Результат:** Нечестный участник забирает себе **бóльшую долю** общей полосы пропускания в ущерб другим. Это было особенно актуально в эпоху доминирования алгоритма `reno`, против которого существовали агрессивные варианты.

#### **Способ 4: Атака на новые алгоритмы (BBR)**

- **`bbr` (Bottleneck Bandwidth and Round-trip propagation time)** — это современный алгоритм от Google. Он не использует потерю пакетов как главный сигнал, а пытается измерить реальную пропускную способность канала и задержку.
- **Уязвимость `bbr`:** В первой версии он мог быть слишком агрессивным. Если в сети есть буферы (например, в роутере), `bbr` может намеренно их заполнять, создавая очередь. Злоумышленник может усилить этот эффект, создавая множество соединений по `bbr`, что вызовет **раздувание буферов и увеличение задержек (RTT) для всех остальных пользователей**, вплоть до полного отказа в обслуживании (Bufferbloat attack).

### **Практическая значимость для белого хакера:**

1. **Сетевой пентест / Red Team:** Понимание этих атак помогает оценить устойчивость корпоративной сети к низкоуровневым DoS-атакам, которые могут обходить традиционные защиты на уровне приложений.
2. **Анализ инцидентов:** Странное "торможение" определенных соединений, не связанное с нагрузкой на сервер, может быть признаком такой целевой атаки.
3. **Разработка защищенных систем:** Если вы создаете кастомные сетевые протоколы или высоконагруженные системы (CDN, игровые серверы), вы должны учитывать эти векторы.  

**Важно:** В чистом виде эти атаки сегодня **встречаются реже**, чем атаки на прикладном уровне (HTTP), потому что:

- Требуют положения Man-in-the-Middle или доступа к сетевому трафику.
- Современные операционные системы имеют более совершенные и разнообразные реализации TCP, что усложняет атаку.
- Шифрование (TLS/HTTPS) затрудняет анализ и подделку данных на транспортном уровне.

**Вывод:** Атаках на механизмы управления TCP - это **целенаправленном манипулировании фундаментальными сигналами (ACK, потери), на которых основана логика работы TCP**, чтобы нарушить его нормальное поведение — либо замедлив жертву, либо получив несправедливое преимущество. Это глубокий, "академический" слой сетевой безопасности, показывающий, что даже базовые протоколы не идеальны.

---

# **Часть 2: HTTP-заголовки — Метаданные, которые говорят всё**

**HTTP-заголовок** — это строки в формате `Имя: Значение`, добавляемые к HTTP-запросу или ответу. Это **метаданные**, управляющие обработкой данных.

**Зачем их так много?** HTTP эволюционировал от простого текстового протокола к сложной системе. Это стандарт, который должен быть расширяемым. Появляются новые браузеры, сервер должен понимать как клиент подключился, каждый браузер по разному обрабатывает информацию, серверу нужно идентифицировать пользователей. Новые хедеры под мобильные устройства и их браузеры.

1. **Содержание:** `Content-Type`, `Content-Length`, `Content-Encoding` (gzip, br).
2. **Кэширование:** `Cache-Control`, `ETag`, `Last-Modified` (ускорение работы, но и вектор для атак).
3. **Безопасность:** `Set-Cookie`, `Authorization`, `CORS`-заголовки (`Access-Control-Allow-Origin`), `Content-Security-Policy` (CSP), `X-Frame-Options`.
4. **Управление соединением:** `Connection`, `Upgrade` (для перехода на WebSocket), `Cookie`
5. **Клиентская идентификация:** `User-Agent`, `Accept-Language`, `Host`.
6. **Прокси и инфраструктура (SDN, балансировщики):** `X-Forwarded-For`, `X-Real-IP`, `X-Forwarded-Proto` (очень важны для атак!).
7. **Кастомные заголовки:** Приложения добавляют свои (`X-API-Key`, `X-CSRF-Token`).

**Сервер может игнорировать заголовки?** Да, но это нарушает стандарт и может сломать функциональность. Заголовки из пространства `X-` — нестандартные, их обработка полностью на совести разработчика.

---

### **Часть 3: Атаки на HTTP-заголовки (Взгляд белого хакера)**

#### **1. Подмена заголовка `Host` (Host Header Injection)**

**Суть:** Если сервер слепо доверяет заголовку `Host` из запроса (например, для генерации ссылок, редиректов, в SSRF), злоумышленник может подменить его.

**Последствия:**
>- **Обход контроля доступа** (если правила привязаны к домену).
>- **Отравление кэша веб-приложений (Web Cache Poisoning)** — отравленная страница сохранится в кэше и будет выдаваться другим пользователям.
>- **SSRF (Server-Side Request Forgery)** — заставить сервер делать запросы к внутренним ресурсам.

**Защита:** Сервер должен явно конфигурировать допустимые домены и не использовать `Host` для критических операций.

---

#### **2. Спуфинг `X-Forwarded-For` и `X-Real-IP`**

**Суть:** Эти заголовки используются прокси/балансировщиками, чтобы сообщить бэкенд-серверу реальный IP клиента. Если приложение доверяет им без проверки (например, для логов или контроля доступа по IP), злоумышленник может подставить любое значение.

**Последствия:**
>- **Сокрытие реального IP** (`X-Forwarded-For: 1.1.1.1`).
>- **Обход IP-фильтров** (например, доступ к админке только с офисного IP).
>- **Отравление логов (Log Poisoning)** — внедрение в логи ложных записей или вредоносных данных (XSS в логи, которые потом просматривает администратор).

**Защита:** Балансировщик должен перезаписывать эти заголовки, а бэкенд — доверять только ему.

---

#### **3. CRLF-инъекция (Carriage Return Line Feed — `\r\n`)**

- **Суть:** Если ввод пользователя, содержащий символы `\r\n`, попадает в HTTP-заголовки без фильтрации, можно разорвать строку и **внедрить новые заголовки или даже тело ответа**.
- **Пример:** `параметр = значение\r\nX-Forwarded-For: 1.1.1.1\r\nВторой-заголовок: данные`

**Последствия:**
>- **HTTP Response Splitting / HTTP Request Smuggling:** Разделение ответа, создание "ложного" запроса внутри.
>- **Обход фильтров, XSS, отравление кэша.**

 **Примечание:** CRLF-инъекции опасны не только в HTTP, но и в почтовых протоколах (spoofing писем), в системных командах.

**Защита:** Валидация и кодирование пользовательского ввода, запрет на `\r\n` в данных для заголовков.

---

#### **4. Неправильная конфигурация CORS (Cross-Origin Resource Sharing)**

- **Суть:** Заголовок `Access-Control-Allow-Origin` определяет, с каких доменов можно обращаться к ресурсам.
- **Ошибка:** Установка значения `*` (звездочка) для приватных данных или данных, изменяемых через POST.
- **Последствия:** Злонамеренный сайт может сделать запрос к вашему API от лица пользователя (с его куками) и получить конфиденциальные данные.
- **Защита:** Точно указывать доверенные домены, не использовать `*` для авторизованных запросов.

---

#### **5. Session Puzzling (или Session Variable Overloading)**

- **Суть:** Одна и та же переменная сессии используется для разных целей на разных этапах работы приложения (например, токен для восстановления пароля и токен для аутентификации). Если злоумышленник может задать значение этой переменной на одном этапе, он может обмануть приложение на другом.
- **Пример:** После запроса "забыли пароль" в сессию записывается `user_id`. Если на странице входа приложение проверяет эту же переменную, можно подставить чужой `user_id` и войти без пароля.
- **Защита:** Использовать разные, уникальные имена переменных для разных функциональных возможностей. Лучше использовать **JWT** или другие токены, где назначение явно указано в теле, а целостность защищена подписью.

---

#### **6. HTTP Request Smuggling (Контрабанда запросов)**

- **Суть:** Сложная атака, использующая расхождения в обработке заголовков `Content-Length` и `Transfer-Encoding` между фронтендом (прокси/балансировщик) и бэкенд-сервером.
- **Механика:** Злоумышленник создает "двусмысленный" HTTP-запрос, который фронтенд и бэкенд интерпретируют по-разному. Это позволяет "протащить" (smuggle) скрытый запрос, который будет обработан от лица следующего легитимного пользователя. Уязвимость возникает из-за неоднозначности в определении конца тела запроса в HTTP/1.1. Используются два заголовка:
> - **`Content-Length` (CL)**: Указывает точную длину тела в байтах.
 >- **`Transfer-Encoding: chunked` (TE)**: Указывает, что тело разбито на "чанки" (блоки).
>
>Основные варианты: **CL.TE, TE.CL, TE.TE**.
- **Влияние:** Обход защиты, кража сессий, XSS, усиление других атак. **Атака разная для HTTP/1.1 и HTTP/2**, так как в HTTP/2 используется бинарный формат, и атаки часто связаны с downgrade до HTTP/1.1.
- **Защита:** Строгая конфигурация инфраструктуры, отключение поддержки сжатия TE, использование HTTP/2 end-to-end.

- **Против Request Smuggling**: По возможности используйте **HTTP/2 end-to-end**, так как этот протокол имеет однозначный механизм определения границ запроса. Нормализуйте запросы на фронтенде, отключайте поддержку chunked-кодирования во входящих запросах, используйте одинаковое ПО на фронтенде и бэкенде.

---

#### **6.1. HTTP Desync / Client-Side Desync

HTTP Desync - это **новый класс атак**, развивающий идею Request Smuggling.

**Ключевое отличие**: Вместо создания рассинхронизации между фронтендом и бэкендом, атака **десинхронизирует соединение между браузером жертвы и фронтенд-сервером**.

**Как работает**:

1. **Вектор**: Находится конечная точка на целевом сервере, которая **не читает всё тело `POST`-запроса** (например, статичный файл, точка редиректа).
2. **Отравление**: Жертву через XSS или вредоносный сайт заставляют отправить такой `POST`-запрос. Сервер отвечает, не дочитав тело, и оставляет соединение открытым для повторного использования.
3. **Эксплуатация**: Браузер жертвы немедленно отправляет по тому же соединению новый запрос (например, при навигации). Сервер считает его **продолжением тела первого запроса**. Это позволяет атакующему управлять началом второго запроса, что может привести к выполнению действий от имени жертвы.

Это особенно опасно, так как может работать против **любых сайтов**, даже с одним сервером, и не требует сложной цепочки серверов.

- **Против Client-Side Desync**: На сервере отключайте повторное использование соединений (keep-alive) для запросов с "нечитаемыми" телами или гарантируйте полное чтение тела запроса перед отправкой ответа.

---

#### **7. Cache Poisoning / Deception через заголовки

Эта атака основана на том, что **кэш (промежуточный или браузера) сохраняет вредоносный ответ и начинает отдавать его другим пользователям**.

**Механизм атаки**: Уязвимость возникает, когда ответ сервера зависит от значения в заголовке запроса (например, `Origin`, `X-Forwarded-Host`), но **этот заголовок не включается в "ключ" кеша**. Злоумышленник отправляет запрос с поддельным заголовком, сервер формирует вредоносный ответ (например, с подменённым JavaScript-файлом), и этот ответ кешируется.

- **Пример из практики**: Если сервер некорректно настроил CORS и отражает заголовок `Origin` в ответе `Access-Control-Allow-Origin`, но не учитывает его в ключе кеша, можно отравить кеш. После этого все другие пользователи, запрашивающие этот ресурс, получат ответ с заголовком, разрешающим доступ атакующему домену, что может привести к утечке данных или DoS.
- **Новая грань**: Исследования показали, что можно отравлять **кэш самого браузера жертвы** через Fetch API. Если ответ кешируется браузером, то при последующей навигации на ту же страницу будет выполнен вредоносный контент.

**Против Cache Poisoning**: Используйте заголовок `Vary` для указания заголовков, влияющих на ответ (например, `Vary: Origin`). Чётко настраивайте CORS и избегайте отражения пользовательского ввода в заголовках ответов. Контролируйте политики кеширования (`Cache-Control`)

---

### **Практика для белого хакера:**

**Вывод:** Понимание работы TCP/UDP и HTTP-заголовков — это ключ к анализу потока данных в сети. Для белого хакера это фундамент для поиска уязвимостей на **транспортном** и **прикладном** уровнях, где большинство современных веб-атак и происходит.